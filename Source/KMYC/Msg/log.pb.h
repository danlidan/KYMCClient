// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: log.proto

#ifndef PROTOBUF_log_2eproto__INCLUDED
#define PROTOBUF_log_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_log_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsRegisterReqImpl();
void InitDefaultsRegisterReq();
void InitDefaultsRegisterRspImpl();
void InitDefaultsRegisterRsp();
void InitDefaultsLoginReqImpl();
void InitDefaultsLoginReq();
void InitDefaultsLoginRspImpl();
void InitDefaultsLoginRsp();
void InitDefaultsMatchReqImpl();
void InitDefaultsMatchReq();
void InitDefaultsplayerInfoBeginImpl();
void InitDefaultsplayerInfoBegin();
void InitDefaultsMatchRspImpl();
void InitDefaultsMatchRsp();
void InitDefaultsMatchCancelReqImpl();
void InitDefaultsMatchCancelReq();
void InitDefaultsMatchCancelRspImpl();
void InitDefaultsMatchCancelRsp();
inline void InitDefaults() {
  InitDefaultsRegisterReq();
  InitDefaultsRegisterRsp();
  InitDefaultsLoginReq();
  InitDefaultsLoginRsp();
  InitDefaultsMatchReq();
  InitDefaultsplayerInfoBegin();
  InitDefaultsMatchRsp();
  InitDefaultsMatchCancelReq();
  InitDefaultsMatchCancelRsp();
}
}  // namespace protobuf_log_2eproto
namespace msg {
class LoginReq;
class LoginReqDefaultTypeInternal;
extern LoginReqDefaultTypeInternal _LoginReq_default_instance_;
class LoginRsp;
class LoginRspDefaultTypeInternal;
extern LoginRspDefaultTypeInternal _LoginRsp_default_instance_;
class MatchCancelReq;
class MatchCancelReqDefaultTypeInternal;
extern MatchCancelReqDefaultTypeInternal _MatchCancelReq_default_instance_;
class MatchCancelRsp;
class MatchCancelRspDefaultTypeInternal;
extern MatchCancelRspDefaultTypeInternal _MatchCancelRsp_default_instance_;
class MatchReq;
class MatchReqDefaultTypeInternal;
extern MatchReqDefaultTypeInternal _MatchReq_default_instance_;
class MatchRsp;
class MatchRspDefaultTypeInternal;
extern MatchRspDefaultTypeInternal _MatchRsp_default_instance_;
class RegisterReq;
class RegisterReqDefaultTypeInternal;
extern RegisterReqDefaultTypeInternal _RegisterReq_default_instance_;
class RegisterRsp;
class RegisterRspDefaultTypeInternal;
extern RegisterRspDefaultTypeInternal _RegisterRsp_default_instance_;
class playerInfoBegin;
class playerInfoBeginDefaultTypeInternal;
extern playerInfoBeginDefaultTypeInternal _playerInfoBegin_default_instance_;
}  // namespace msg
namespace msg {

// ===================================================================

class RegisterReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:msg.RegisterReq) */ {
 public:
  RegisterReq();
  virtual ~RegisterReq();

  RegisterReq(const RegisterReq& from);

  inline RegisterReq& operator=(const RegisterReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterReq(RegisterReq&& from) noexcept
    : RegisterReq() {
    *this = ::std::move(from);
  }

  inline RegisterReq& operator=(RegisterReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterReq* internal_default_instance() {
    return reinterpret_cast<const RegisterReq*>(
               &_RegisterReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(RegisterReq* other);
  friend void swap(RegisterReq& a, RegisterReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterReq* New() const PROTOBUF_FINAL { return New(NULL); }

  RegisterReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RegisterReq& from);
  void MergeFrom(const RegisterReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RegisterReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string pass = 2;
  void clear_pass();
  static const int kPassFieldNumber = 2;
  const ::std::string& pass() const;
  void set_pass(const ::std::string& value);
  #if LANG_CXX11
  void set_pass(::std::string&& value);
  #endif
  void set_pass(const char* value);
  void set_pass(const char* value, size_t size);
  ::std::string* mutable_pass();
  ::std::string* release_pass();
  void set_allocated_pass(::std::string* pass);

  // @@protoc_insertion_point(class_scope:msg.RegisterReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr pass_;
  mutable int _cached_size_;
  friend struct ::protobuf_log_2eproto::TableStruct;
  friend void ::protobuf_log_2eproto::InitDefaultsRegisterReqImpl();
};
// -------------------------------------------------------------------

class RegisterRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:msg.RegisterRsp) */ {
 public:
  RegisterRsp();
  virtual ~RegisterRsp();

  RegisterRsp(const RegisterRsp& from);

  inline RegisterRsp& operator=(const RegisterRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterRsp(RegisterRsp&& from) noexcept
    : RegisterRsp() {
    *this = ::std::move(from);
  }

  inline RegisterRsp& operator=(RegisterRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterRsp* internal_default_instance() {
    return reinterpret_cast<const RegisterRsp*>(
               &_RegisterRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(RegisterRsp* other);
  friend void swap(RegisterRsp& a, RegisterRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  RegisterRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RegisterRsp& from);
  void MergeFrom(const RegisterRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RegisterRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool success = 1;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:msg.RegisterRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool success_;
  mutable int _cached_size_;
  friend struct ::protobuf_log_2eproto::TableStruct;
  friend void ::protobuf_log_2eproto::InitDefaultsRegisterRspImpl();
};
// -------------------------------------------------------------------

class LoginReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:msg.LoginReq) */ {
 public:
  LoginReq();
  virtual ~LoginReq();

  LoginReq(const LoginReq& from);

  inline LoginReq& operator=(const LoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginReq(LoginReq&& from) noexcept
    : LoginReq() {
    *this = ::std::move(from);
  }

  inline LoginReq& operator=(LoginReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginReq* internal_default_instance() {
    return reinterpret_cast<const LoginReq*>(
               &_LoginReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(LoginReq* other);
  friend void swap(LoginReq& a, LoginReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginReq* New() const PROTOBUF_FINAL { return New(NULL); }

  LoginReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoginReq& from);
  void MergeFrom(const LoginReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoginReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string pass = 2;
  void clear_pass();
  static const int kPassFieldNumber = 2;
  const ::std::string& pass() const;
  void set_pass(const ::std::string& value);
  #if LANG_CXX11
  void set_pass(::std::string&& value);
  #endif
  void set_pass(const char* value);
  void set_pass(const char* value, size_t size);
  ::std::string* mutable_pass();
  ::std::string* release_pass();
  void set_allocated_pass(::std::string* pass);

  // @@protoc_insertion_point(class_scope:msg.LoginReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr pass_;
  mutable int _cached_size_;
  friend struct ::protobuf_log_2eproto::TableStruct;
  friend void ::protobuf_log_2eproto::InitDefaultsLoginReqImpl();
};
// -------------------------------------------------------------------

class LoginRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:msg.LoginRsp) */ {
 public:
  LoginRsp();
  virtual ~LoginRsp();

  LoginRsp(const LoginRsp& from);

  inline LoginRsp& operator=(const LoginRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginRsp(LoginRsp&& from) noexcept
    : LoginRsp() {
    *this = ::std::move(from);
  }

  inline LoginRsp& operator=(LoginRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginRsp* internal_default_instance() {
    return reinterpret_cast<const LoginRsp*>(
               &_LoginRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(LoginRsp* other);
  friend void swap(LoginRsp& a, LoginRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  LoginRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoginRsp& from);
  void MergeFrom(const LoginRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoginRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bool success = 1;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // int32 rank = 3;
  void clear_rank();
  static const int kRankFieldNumber = 3;
  ::google::protobuf::int32 rank() const;
  void set_rank(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.LoginRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  bool success_;
  ::google::protobuf::int32 rank_;
  mutable int _cached_size_;
  friend struct ::protobuf_log_2eproto::TableStruct;
  friend void ::protobuf_log_2eproto::InitDefaultsLoginRspImpl();
};
// -------------------------------------------------------------------

class MatchReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:msg.MatchReq) */ {
 public:
  MatchReq();
  virtual ~MatchReq();

  MatchReq(const MatchReq& from);

  inline MatchReq& operator=(const MatchReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MatchReq(MatchReq&& from) noexcept
    : MatchReq() {
    *this = ::std::move(from);
  }

  inline MatchReq& operator=(MatchReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MatchReq* internal_default_instance() {
    return reinterpret_cast<const MatchReq*>(
               &_MatchReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(MatchReq* other);
  friend void swap(MatchReq& a, MatchReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MatchReq* New() const PROTOBUF_FINAL { return New(NULL); }

  MatchReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MatchReq& from);
  void MergeFrom(const MatchReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MatchReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.MatchReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 type_;
  mutable int _cached_size_;
  friend struct ::protobuf_log_2eproto::TableStruct;
  friend void ::protobuf_log_2eproto::InitDefaultsMatchReqImpl();
};
// -------------------------------------------------------------------

class playerInfoBegin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:msg.playerInfoBegin) */ {
 public:
  playerInfoBegin();
  virtual ~playerInfoBegin();

  playerInfoBegin(const playerInfoBegin& from);

  inline playerInfoBegin& operator=(const playerInfoBegin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  playerInfoBegin(playerInfoBegin&& from) noexcept
    : playerInfoBegin() {
    *this = ::std::move(from);
  }

  inline playerInfoBegin& operator=(playerInfoBegin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const playerInfoBegin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const playerInfoBegin* internal_default_instance() {
    return reinterpret_cast<const playerInfoBegin*>(
               &_playerInfoBegin_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(playerInfoBegin* other);
  friend void swap(playerInfoBegin& a, playerInfoBegin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline playerInfoBegin* New() const PROTOBUF_FINAL { return New(NULL); }

  playerInfoBegin* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const playerInfoBegin& from);
  void MergeFrom(const playerInfoBegin& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(playerInfoBegin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // int32 playerId = 1;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::int32 playerid() const;
  void set_playerid(::google::protobuf::int32 value);

  // int32 rank = 3;
  void clear_rank();
  static const int kRankFieldNumber = 3;
  ::google::protobuf::int32 rank() const;
  void set_rank(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.playerInfoBegin)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 playerid_;
  ::google::protobuf::int32 rank_;
  mutable int _cached_size_;
  friend struct ::protobuf_log_2eproto::TableStruct;
  friend void ::protobuf_log_2eproto::InitDefaultsplayerInfoBeginImpl();
};
// -------------------------------------------------------------------

class MatchRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:msg.MatchRsp) */ {
 public:
  MatchRsp();
  virtual ~MatchRsp();

  MatchRsp(const MatchRsp& from);

  inline MatchRsp& operator=(const MatchRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MatchRsp(MatchRsp&& from) noexcept
    : MatchRsp() {
    *this = ::std::move(from);
  }

  inline MatchRsp& operator=(MatchRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MatchRsp* internal_default_instance() {
    return reinterpret_cast<const MatchRsp*>(
               &_MatchRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(MatchRsp* other);
  friend void swap(MatchRsp& a, MatchRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MatchRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  MatchRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MatchRsp& from);
  void MergeFrom(const MatchRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MatchRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .msg.playerInfoBegin players = 3;
  int players_size() const;
  void clear_players();
  static const int kPlayersFieldNumber = 3;
  const ::msg::playerInfoBegin& players(int index) const;
  ::msg::playerInfoBegin* mutable_players(int index);
  ::msg::playerInfoBegin* add_players();
  ::google::protobuf::RepeatedPtrField< ::msg::playerInfoBegin >*
      mutable_players();
  const ::google::protobuf::RepeatedPtrField< ::msg::playerInfoBegin >&
      players() const;

  // int32 playerNum = 1;
  void clear_playernum();
  static const int kPlayerNumFieldNumber = 1;
  ::google::protobuf::int32 playernum() const;
  void set_playernum(::google::protobuf::int32 value);

  // int32 myPlayerId = 2;
  void clear_myplayerid();
  static const int kMyPlayerIdFieldNumber = 2;
  ::google::protobuf::int32 myplayerid() const;
  void set_myplayerid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.MatchRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::msg::playerInfoBegin > players_;
  ::google::protobuf::int32 playernum_;
  ::google::protobuf::int32 myplayerid_;
  mutable int _cached_size_;
  friend struct ::protobuf_log_2eproto::TableStruct;
  friend void ::protobuf_log_2eproto::InitDefaultsMatchRspImpl();
};
// -------------------------------------------------------------------

class MatchCancelReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:msg.MatchCancelReq) */ {
 public:
  MatchCancelReq();
  virtual ~MatchCancelReq();

  MatchCancelReq(const MatchCancelReq& from);

  inline MatchCancelReq& operator=(const MatchCancelReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MatchCancelReq(MatchCancelReq&& from) noexcept
    : MatchCancelReq() {
    *this = ::std::move(from);
  }

  inline MatchCancelReq& operator=(MatchCancelReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchCancelReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MatchCancelReq* internal_default_instance() {
    return reinterpret_cast<const MatchCancelReq*>(
               &_MatchCancelReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(MatchCancelReq* other);
  friend void swap(MatchCancelReq& a, MatchCancelReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MatchCancelReq* New() const PROTOBUF_FINAL { return New(NULL); }

  MatchCancelReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MatchCancelReq& from);
  void MergeFrom(const MatchCancelReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MatchCancelReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:msg.MatchCancelReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_log_2eproto::TableStruct;
  friend void ::protobuf_log_2eproto::InitDefaultsMatchCancelReqImpl();
};
// -------------------------------------------------------------------

class MatchCancelRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:msg.MatchCancelRsp) */ {
 public:
  MatchCancelRsp();
  virtual ~MatchCancelRsp();

  MatchCancelRsp(const MatchCancelRsp& from);

  inline MatchCancelRsp& operator=(const MatchCancelRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MatchCancelRsp(MatchCancelRsp&& from) noexcept
    : MatchCancelRsp() {
    *this = ::std::move(from);
  }

  inline MatchCancelRsp& operator=(MatchCancelRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchCancelRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MatchCancelRsp* internal_default_instance() {
    return reinterpret_cast<const MatchCancelRsp*>(
               &_MatchCancelRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(MatchCancelRsp* other);
  friend void swap(MatchCancelRsp& a, MatchCancelRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MatchCancelRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  MatchCancelRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MatchCancelRsp& from);
  void MergeFrom(const MatchCancelRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MatchCancelRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool success = 1;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:msg.MatchCancelRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool success_;
  mutable int _cached_size_;
  friend struct ::protobuf_log_2eproto::TableStruct;
  friend void ::protobuf_log_2eproto::InitDefaultsMatchCancelRspImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RegisterReq

// string name = 1;
inline void RegisterReq::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RegisterReq::name() const {
  // @@protoc_insertion_point(field_get:msg.RegisterReq.name)
  return name_.GetNoArena();
}
inline void RegisterReq::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:msg.RegisterReq.name)
}
#if LANG_CXX11
inline void RegisterReq::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:msg.RegisterReq.name)
}
#endif
inline void RegisterReq::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:msg.RegisterReq.name)
}
inline void RegisterReq::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:msg.RegisterReq.name)
}
inline ::std::string* RegisterReq::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:msg.RegisterReq.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterReq::release_name() {
  // @@protoc_insertion_point(field_release:msg.RegisterReq.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterReq::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:msg.RegisterReq.name)
}

// string pass = 2;
inline void RegisterReq::clear_pass() {
  pass_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RegisterReq::pass() const {
  // @@protoc_insertion_point(field_get:msg.RegisterReq.pass)
  return pass_.GetNoArena();
}
inline void RegisterReq::set_pass(const ::std::string& value) {
  
  pass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:msg.RegisterReq.pass)
}
#if LANG_CXX11
inline void RegisterReq::set_pass(::std::string&& value) {
  
  pass_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:msg.RegisterReq.pass)
}
#endif
inline void RegisterReq::set_pass(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:msg.RegisterReq.pass)
}
inline void RegisterReq::set_pass(const char* value, size_t size) {
  
  pass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:msg.RegisterReq.pass)
}
inline ::std::string* RegisterReq::mutable_pass() {
  
  // @@protoc_insertion_point(field_mutable:msg.RegisterReq.pass)
  return pass_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterReq::release_pass() {
  // @@protoc_insertion_point(field_release:msg.RegisterReq.pass)
  
  return pass_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterReq::set_allocated_pass(::std::string* pass) {
  if (pass != NULL) {
    
  } else {
    
  }
  pass_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pass);
  // @@protoc_insertion_point(field_set_allocated:msg.RegisterReq.pass)
}

// -------------------------------------------------------------------

// RegisterRsp

// bool success = 1;
inline void RegisterRsp::clear_success() {
  success_ = false;
}
inline bool RegisterRsp::success() const {
  // @@protoc_insertion_point(field_get:msg.RegisterRsp.success)
  return success_;
}
inline void RegisterRsp::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:msg.RegisterRsp.success)
}

// -------------------------------------------------------------------

// LoginReq

// string name = 1;
inline void LoginReq::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginReq::name() const {
  // @@protoc_insertion_point(field_get:msg.LoginReq.name)
  return name_.GetNoArena();
}
inline void LoginReq::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:msg.LoginReq.name)
}
#if LANG_CXX11
inline void LoginReq::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:msg.LoginReq.name)
}
#endif
inline void LoginReq::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:msg.LoginReq.name)
}
inline void LoginReq::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:msg.LoginReq.name)
}
inline ::std::string* LoginReq::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:msg.LoginReq.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginReq::release_name() {
  // @@protoc_insertion_point(field_release:msg.LoginReq.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginReq::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:msg.LoginReq.name)
}

// string pass = 2;
inline void LoginReq::clear_pass() {
  pass_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginReq::pass() const {
  // @@protoc_insertion_point(field_get:msg.LoginReq.pass)
  return pass_.GetNoArena();
}
inline void LoginReq::set_pass(const ::std::string& value) {
  
  pass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:msg.LoginReq.pass)
}
#if LANG_CXX11
inline void LoginReq::set_pass(::std::string&& value) {
  
  pass_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:msg.LoginReq.pass)
}
#endif
inline void LoginReq::set_pass(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:msg.LoginReq.pass)
}
inline void LoginReq::set_pass(const char* value, size_t size) {
  
  pass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:msg.LoginReq.pass)
}
inline ::std::string* LoginReq::mutable_pass() {
  
  // @@protoc_insertion_point(field_mutable:msg.LoginReq.pass)
  return pass_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginReq::release_pass() {
  // @@protoc_insertion_point(field_release:msg.LoginReq.pass)
  
  return pass_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginReq::set_allocated_pass(::std::string* pass) {
  if (pass != NULL) {
    
  } else {
    
  }
  pass_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pass);
  // @@protoc_insertion_point(field_set_allocated:msg.LoginReq.pass)
}

// -------------------------------------------------------------------

// LoginRsp

// bool success = 1;
inline void LoginRsp::clear_success() {
  success_ = false;
}
inline bool LoginRsp::success() const {
  // @@protoc_insertion_point(field_get:msg.LoginRsp.success)
  return success_;
}
inline void LoginRsp::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:msg.LoginRsp.success)
}

// string name = 2;
inline void LoginRsp::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRsp::name() const {
  // @@protoc_insertion_point(field_get:msg.LoginRsp.name)
  return name_.GetNoArena();
}
inline void LoginRsp::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:msg.LoginRsp.name)
}
#if LANG_CXX11
inline void LoginRsp::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:msg.LoginRsp.name)
}
#endif
inline void LoginRsp::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:msg.LoginRsp.name)
}
inline void LoginRsp::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:msg.LoginRsp.name)
}
inline ::std::string* LoginRsp::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:msg.LoginRsp.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRsp::release_name() {
  // @@protoc_insertion_point(field_release:msg.LoginRsp.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRsp::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:msg.LoginRsp.name)
}

// int32 rank = 3;
inline void LoginRsp::clear_rank() {
  rank_ = 0;
}
inline ::google::protobuf::int32 LoginRsp::rank() const {
  // @@protoc_insertion_point(field_get:msg.LoginRsp.rank)
  return rank_;
}
inline void LoginRsp::set_rank(::google::protobuf::int32 value) {
  
  rank_ = value;
  // @@protoc_insertion_point(field_set:msg.LoginRsp.rank)
}

// -------------------------------------------------------------------

// MatchReq

// int32 type = 1;
inline void MatchReq::clear_type() {
  type_ = 0;
}
inline ::google::protobuf::int32 MatchReq::type() const {
  // @@protoc_insertion_point(field_get:msg.MatchReq.type)
  return type_;
}
inline void MatchReq::set_type(::google::protobuf::int32 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:msg.MatchReq.type)
}

// -------------------------------------------------------------------

// playerInfoBegin

// int32 playerId = 1;
inline void playerInfoBegin::clear_playerid() {
  playerid_ = 0;
}
inline ::google::protobuf::int32 playerInfoBegin::playerid() const {
  // @@protoc_insertion_point(field_get:msg.playerInfoBegin.playerId)
  return playerid_;
}
inline void playerInfoBegin::set_playerid(::google::protobuf::int32 value) {
  
  playerid_ = value;
  // @@protoc_insertion_point(field_set:msg.playerInfoBegin.playerId)
}

// string name = 2;
inline void playerInfoBegin::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& playerInfoBegin::name() const {
  // @@protoc_insertion_point(field_get:msg.playerInfoBegin.name)
  return name_.GetNoArena();
}
inline void playerInfoBegin::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:msg.playerInfoBegin.name)
}
#if LANG_CXX11
inline void playerInfoBegin::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:msg.playerInfoBegin.name)
}
#endif
inline void playerInfoBegin::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:msg.playerInfoBegin.name)
}
inline void playerInfoBegin::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:msg.playerInfoBegin.name)
}
inline ::std::string* playerInfoBegin::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:msg.playerInfoBegin.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* playerInfoBegin::release_name() {
  // @@protoc_insertion_point(field_release:msg.playerInfoBegin.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void playerInfoBegin::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:msg.playerInfoBegin.name)
}

// int32 rank = 3;
inline void playerInfoBegin::clear_rank() {
  rank_ = 0;
}
inline ::google::protobuf::int32 playerInfoBegin::rank() const {
  // @@protoc_insertion_point(field_get:msg.playerInfoBegin.rank)
  return rank_;
}
inline void playerInfoBegin::set_rank(::google::protobuf::int32 value) {
  
  rank_ = value;
  // @@protoc_insertion_point(field_set:msg.playerInfoBegin.rank)
}

// -------------------------------------------------------------------

// MatchRsp

// int32 playerNum = 1;
inline void MatchRsp::clear_playernum() {
  playernum_ = 0;
}
inline ::google::protobuf::int32 MatchRsp::playernum() const {
  // @@protoc_insertion_point(field_get:msg.MatchRsp.playerNum)
  return playernum_;
}
inline void MatchRsp::set_playernum(::google::protobuf::int32 value) {
  
  playernum_ = value;
  // @@protoc_insertion_point(field_set:msg.MatchRsp.playerNum)
}

// int32 myPlayerId = 2;
inline void MatchRsp::clear_myplayerid() {
  myplayerid_ = 0;
}
inline ::google::protobuf::int32 MatchRsp::myplayerid() const {
  // @@protoc_insertion_point(field_get:msg.MatchRsp.myPlayerId)
  return myplayerid_;
}
inline void MatchRsp::set_myplayerid(::google::protobuf::int32 value) {
  
  myplayerid_ = value;
  // @@protoc_insertion_point(field_set:msg.MatchRsp.myPlayerId)
}

// repeated .msg.playerInfoBegin players = 3;
inline int MatchRsp::players_size() const {
  return players_.size();
}
inline void MatchRsp::clear_players() {
  players_.Clear();
}
inline const ::msg::playerInfoBegin& MatchRsp::players(int index) const {
  // @@protoc_insertion_point(field_get:msg.MatchRsp.players)
  return players_.Get(index);
}
inline ::msg::playerInfoBegin* MatchRsp::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:msg.MatchRsp.players)
  return players_.Mutable(index);
}
inline ::msg::playerInfoBegin* MatchRsp::add_players() {
  // @@protoc_insertion_point(field_add:msg.MatchRsp.players)
  return players_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::msg::playerInfoBegin >*
MatchRsp::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:msg.MatchRsp.players)
  return &players_;
}
inline const ::google::protobuf::RepeatedPtrField< ::msg::playerInfoBegin >&
MatchRsp::players() const {
  // @@protoc_insertion_point(field_list:msg.MatchRsp.players)
  return players_;
}

// -------------------------------------------------------------------

// MatchCancelReq

// -------------------------------------------------------------------

// MatchCancelRsp

// bool success = 1;
inline void MatchCancelRsp::clear_success() {
  success_ = false;
}
inline bool MatchCancelRsp::success() const {
  // @@protoc_insertion_point(field_get:msg.MatchCancelRsp.success)
  return success_;
}
inline void MatchCancelRsp::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:msg.MatchCancelRsp.success)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace msg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_log_2eproto__INCLUDED
